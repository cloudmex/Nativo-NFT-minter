
    pub fn obtener_pagina_v3(&self, from_index: u64, limit: u64) -> Vec<Meta>  {
        // no estoy segyri de como convierte  de U128 a u128
      /*   let start_index: u128 = Some(from_index).map(|v| v as u128).unwrap_or_default();
        let limit = Some(limit).map(|v| v as usize).unwrap_or(usize::MAX);
        let inicioPag = start_index as usize * limit; */

        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        //let mut counter: usize = from_index;
        log!("  from  -> : {},to -> {}",&from_index,&limit);
        let mut _tokfound =from_index;  //0
        let totoal =  self.get_on_total_toks();
                log!(" {}" ,&totoal);
            for x in from_index..limit { 
                
                if  x>= totoal.clone() {
                    break;
                }
                    let mut token =self.get_token(x.to_string().clone());
                /*     log!("  x -> : {},token {}",&x,&token.token_id );
                  */   log!("  token -> : {:?}",token.token_id.clone() );
                 
                    if token.on_sale{
                        
                    vectMEta.push(token  );
                    _tokfound+=1;
                    
                }
                if x== limit {
                    break;
                }
                
                //if( x == limit ){break; }           
            }
            if vectMEta.len()< 12 && limit < totoal {
                let  newfrom =limit; //12
                let  newlimit = limit+30; //24
               
                for y in newfrom..newlimit { 
                 let mut token =self.get_token(y.to_string().clone());
                 log!("  2da vuetla token -> : {:?}",&y );
                     if token.on_sale{
                         
                        vectMEta.push(token  );
                        _tokfound+=1;
                        
                    }
                     if y== newlimit {
                        break;
                    }

                }
            }
           
            vectMEta
         
    }
    pub fn obtener_pagina_v3_by_filtros(&self, from_index: u64, limit: u64,culture: String,country:String) -> Vec<Meta>  {
    
        //Creamos un vector vacio
        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        //let mut counter: usize = from_index;
        log!("  from  -> : {},to -> {},cul ->{},coun ->{} ",&from_index,&limit,&culture,&country);
        let mut _tokfound =from_index;  //0
        let mut reg =0;
        //obtenemos el total de tokens existente
        let totoal =  self.get_on_total_toks();
                log!(" {}" ,&totoal);
             //   hacemos un ciclo desde el indice hasta un limite
            for x in from_index..limit { 
                //si el ciclo va llega al ultimo token disponible sale de este
                if  x>= totoal.clone() {
                    break;
                }
                //obtener el token
                    let mut token =self.get_token(x.to_string().clone());
                
                 //si el token esta a lavente agregar al vect
                 //si los filtros country y culture estan en null
                    if token.on_sale.clone() && culture =="null" && country =="null" {
                            
                        vectMEta.push(token  );
                        _tokfound+=1;
                        reg+=1;
                    }
                 //si    country es diferente de null y culture esta en null
                    else if token.on_sale.clone()  && culture !="null" && country =="null"  {
                        if token.culture == culture{
                            vectMEta.push(token  );
                            _tokfound+=1;
                            reg+=1;
                        }    
                        
                        
                    }
                    //si  country es null y culture es diferente de null
                    else if token.on_sale.clone()  && culture =="null" && country !="null"  {
                        if token.country == country{
                            vectMEta.push(token  );
                            _tokfound+=1;
                            reg+=1;
                        }    
                        
                        
                    }
                    //si los filtros country es diferente de null y culture esta en null
                    else if token.on_sale.clone()  && culture !="null" && country !="null" {
                            
                        if token.culture == culture && token.country == country {
                            vectMEta.push(token  );
                            _tokfound+=1;
                            reg+=1;
                        }  
                        
                    }
                //si el ciclo es igual al limite sale de este
                if x== limit {
                    break;
                }
                
                //if( x == limit ){break; }           
            }
               /*  if vectMEta.len()< 12 && limit < totoal {
                    let  newfrom =limit; //12
                    let  newlimit = limit+30; //24
                
                    for y in newfrom..newlimit { 
                    let mut token =self.get_token(y.to_string().clone());
                    log!("  2da vuetla token -> : {:?}",&y );
                        if token.on_sale{
                            
                            vectMEta.push(token  );
                            _tokfound+=1;
                            
                        }
                        if y== newlimit {
                            break;
                        }

                    }
                } */
           
            log!("  registros  -> : {} ",&reg);
            vectMEta
         
    }
    pub fn obtener_pagina_v3_auction(&self, from_index: u64, limit: u64) -> Vec<Meta>  {
        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");
        //let mut counter: usize = from_index;
       // log!("  from  -> : {},to -> {}",&from_index,&limit);
        let mut _tokfound =from_index;  //0
        let totoal =  self.get_on_total_toks()-1;
                log!(" {}" ,&totoal);
            for x in from_index..limit { 
                if x== limit {
                    break;
                }
                if  x>= totoal.clone() {
                    break;
                }
                    let mut token =self.get_token(x.to_string().clone());
                 
                    if token.on_auction{
                        
                    vectMEta.push(token  );
                    _tokfound+=1;
                    
                }
               
                
               
            }
            if vectMEta.len()< 12 && limit < totoal {
                let  newfrom =limit; //12
                let  newlimit = limit+30; //24
               
                for y in newfrom..newlimit { 
                 let mut token =self.get_token(y.to_string().clone());
              //   log!("  2da vuetla token -> : {:?}",&y );
                     if token.on_auction{
                         
                        vectMEta.push(token  );
                        _tokfound+=1;
                        
                    }
                     if y== newlimit {
                        break;
                    }

                }
            }
           
            vectMEta
         
    }

    
    pub fn obtener_pagina_v4_on_auction(&self) -> Vec<Meta>  {
      
        let mut vectMEta = vec![];
      
       
        let totoal =  self.get_on_total_toks();
        log!("  brakes here  -> : {}",&totoal );
            for x in 0..totoal { 
           
                if x == totoal { break; } 
              
                 let mut token =self.get_token(x.to_string().clone());
            /*    
                log!("  token -> : {:?}",token.token_id.clone() );
             */    
                if token.on_auction{
                        vectMEta.push(token  );
                }
           }
            vectMEta
         
    }

  pub fn obtener_pagina_v4(&self, from_index: u64, limit: u64) -> Vec<Meta>  {
      
        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");  //0 //30 -> 30:45
        //let mut counter: usize = from_index;                //46 //30 -> 30:89                      
        log!("  from  -> : {},to -> {}",&from_index,&limit);
        let mut _tokfound =0;  //0
        let totoal =  self.get_on_total_toks()-1;
                log!(" {}" ,&totoal);
            for x in from_index..totoal { 
                
                if  x>= totoal.clone() { //0 ->150   //29-> 150
                    break;
                }
                    let mut token =self.get_token(x.to_string().clone());
               
                 
                    if token.on_sale{
                        
                    vectMEta.push(token  );
                    _tokfound+=1;
                    
                     }
                if _tokfound== limit {  //1 <30  //30-30
                    break;
                }
                
                          
            }
            
           
            vectMEta
         
    }
    

     // pub fn get_tokens_by_onwer(self,account_id: String, from_index:String,limit:String){
    //     self.tokens.owner_by_id.tokens_per_owner.get(account_id);
    // }


pub fn get_ids_onsale(&self,tokens:u64) ->  Vec<u64> {
        let mut vectIDs = vec![];
        let mut _tokfound =0;
        let totoal =  self.get_on_total_toks();
        vectIDs.push(0); 
        for x in 0..totoal { 
            if  x>= totoal.clone() { break;  }
                let mut token =self.get_token(x.to_string().clone());
                if token.on_sale{
                   _tokfound+=1;
                   if _tokfound== tokens {   
                    vectIDs.push( token.token_id.parse::<u64>().unwrap() );  
                    _tokfound=0;  
                    }
               }
            if _tokfound == tokens {break; }           
        }
        vectIDs
    }

    pub fn get_ids_onsale_v2(&self,tokens:u64) ->  Vec<u64> {
        let mut vectIDs = vec![];
        let mut _tokfound =0;
        let totoal =  self.get_on_total_toks();
        vectIDs.push(0); 
        for x in 0..totoal { 
            if  x>= totoal.clone() { break;  }
                let mut token =self.get_token(x.to_string().clone());
                if token.on_sale{
                   _tokfound+=1;
                   if _tokfound== tokens {   
                    vectIDs.push( token.token_id.parse::<u64>().unwrap() );  
                    _tokfound=0;  
                    }
               }
            if _tokfound == tokens {break; }           
        }
        vectIDs
    }
    pub fn get_ids_onauction(&self,tokens:u64) ->  Vec<u64> {
        //declarar arreglo de ids
       let mut vectIDs = vec![];
       //recorrer el arreglo total 
       let mut _tokfound =0;
       let totoal =  self.get_on_total_toks();
       log!(" {}" ,&totoal);
       vectIDs.push(0);  
       for x in 0..totoal { 
           
           if  x>= totoal.clone() {   
               break;
           }
               let mut token =self.get_token(x.to_string().clone());
           
               if token.on_auction{
                  _tokfound+=1;
                  if _tokfound== tokens {   
                   log!("token #30 {}" ,&token.token_id);
                   vectIDs.push( token.token_id.parse::<u64>().unwrap() );  
                   _tokfound=0;  
                   }
              }
           
           
           if( _tokfound == tokens ){break; }           
       }
           
       vectIDs
   }

   
     /* fn update_token(&mut self, token_id: TokenId, extra: String) -> TokenMetadata {
        //assert!(!env::state_exists(), "Already initialized");
        let mut metadata = self
            .tokens
            .token_metadata_by_id
            .as_ref()
            .and_then(|by_id| by_id.get(&token_id))
            .unwrap();
        let owner_id = self.tokens.owner_by_id.get(&token_id).unwrap();
        //assert_eq!(owner_id!= env::signer_account_id() && owner != ,false,"");
        metadata.extra = Some(extra);
        self.tokens
            .token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &metadata));
        metadata
    } */


    
    pub fn obtener_pagina_v5(&self, from_index: u64, limit: u64,culture: String,country:String) -> Vec<Meta>  {
      
        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");  //0 //30 -> 30:45
        //let mut counter: usize = from_index;                //46 //30 -> 30:89                      
        log!("  from  -> : {},to -> {}",&from_index,&limit);
        let mut _tokfound =0;  
        let mut reg =0;
        let totoal =  self.get_on_total_toks();
                log!(" {}" ,&totoal);
            for x in from_index..totoal { 
                
                if  x>= totoal.clone() { //0 ->150   //29-> 150
                    break;
                }
                    let mut token =self.get_token(x.to_string().clone());
               
                 
                     //si el token esta a lavente agregar al vect
                 //si los filtros country y culture estan en null
                 if token.on_sale.clone() && culture =="null" && country =="null" {
                            
                    vectMEta.push(token  );
                    _tokfound+=1;
                    reg+=1;
                }
             //si    country es diferente de null y culture esta en null
                else if token.on_sale.clone()  && culture !="null" && country =="null"  {
                    if token.culture == culture{
                        vectMEta.push(token  );
                        _tokfound+=1;
                        reg+=1;
                    }    
                    
                    
                }
                //si  country es null y culture es diferente de null
                else if token.on_sale.clone()  && culture =="null" && country !="null"  {
                    if token.country == country{
                        vectMEta.push(token  );
                        _tokfound+=1;
                        reg+=1;
                    }    
                    
                    
                }
                //si los filtros country es diferente de null y culture esta en null
                else if token.on_sale.clone()  && culture !="null" && country !="null" {
                        
                    if token.culture == culture && token.country == country {
                        vectMEta.push(token  );
                        _tokfound+=1;
                        reg+=1;
                    }  
                    
                }
                if _tokfound== limit {  //1 <30  //30-30
                    break;
                }
                
                          
            }
            
            log!("  registros  -> : {} ",&reg);
            vectMEta
         
    }
    pub fn obtener_pagina_v5_auction(&self, from_index: u64, limit: u64,culture: String,country:String) -> Vec<Meta>  {
      
        let mut vectMEta = vec![];
        assert_ne!(limit, 0, "Cannot provide limit of 0.");  //0 //30 -> 30:45
                      //46 //30 -> 30:89                      
        
        let mut _tokfound =0;  
        let mut reg =0;
        let totoal =  self.get_on_total_toks();
                log!(" {}" ,&totoal);
            for x in from_index..totoal { 
                
                if  x>= totoal.clone() { //0 ->150   //29-> 150
                    break;
                }
                    let mut token =self.get_token(x.to_string().clone());
               
                 
                     //si el token esta a lavente agregar al vect
                 //si los filtros country y culture estan en null
                 if token.on_auction.clone() && culture =="null" && country =="null" {
                            
                    vectMEta.push(token  );
                    _tokfound+=1;
                    reg+=1;
                }
             //si    country es diferente de null y culture esta en null
                else if token.on_auction.clone()  && culture !="null" && country =="null"  {
                    if token.culture == culture{
                        vectMEta.push(token  );
                        _tokfound+=1;
                        reg+=1;
                    }    
                    
                    
                }
                //si  country es null y culture es diferente de null
                else if token.on_auction.clone()  && culture =="null" && country !="null"  {
                    if token.country == country{
                        vectMEta.push(token  );
                        _tokfound+=1;
                        reg+=1;
                    }    
                    
                    
                }
                //si los filtros country es diferente de null y culture esta en null
                else if token.on_auction.clone()  && culture !="null" && country !="null" {
                        
                    if token.culture == culture && token.country == country {
                        vectMEta.push(token  );
                        _tokfound+=1;
                        reg+=1;
                    }  
                    
                }
                if _tokfound== limit {  //1 <30  //30-30
                    break;
                }
                
                          
            }
            
            log!("  registros  -> : {} ",&reg);
            vectMEta
         
    }
     //solo obtiene los tokenid que esten en onsale
 pub fn get_by_on_sale(& mut self,tokens: u64,_start_index: u64 ) -> Vec<u64> {
    //insertar nuevo token a Hashmap
    let mut _map =self.tokenHM.clone();
    let mut vectIDs = vec![];
    let ends= _map.len().to_string().parse::<u64>();
    
    //este ciclo recupera los primeros
    for x in _start_index..ends.unwrap()  {
        
        if vectIDs.len() >= tokens as usize { log!("max {} ",&x); break ;}
       
        if _map.get(&x.to_string()).clone() ==Some(&"onsale".to_string()) {
            
                vectIDs.push(x.to_string().parse::<u64>().unwrap() );
            
        }     
         
    }
     
   return vectIDs ;
    
} 




pub fn obtener_pagina_on_auction(&   self,tokens: u64,_start_index: u64 ) -> Vec<Meta> {
        //insertar nuevo token a Hashmap
        let mut _map =self.tokenHM.clone();
        let mut vectIDs = vec![];
        let mut vectMEta = vec![];
        let ends= _map.len().to_string().parse::<u64>();
        
        //este ciclo recupera los primeros
        for x in _start_index..ends.unwrap()  {
            
            if vectIDs.len() >= tokens as usize { log!("max {} ",&x); break ;}
        
            let tok = _map.get(&x.to_string() ).unwrap();
            if tok[0] == "onauction".to_string()  {
                
                    vectIDs.push(x.to_string().parse::<u64>().unwrap() );
                
            }       
            
        }

        let endmeta = vectIDs.len().to_string().parse::<u64>().unwrap();
        //en este ciclo recupera los tokens que encontramos anteriormente
          for x in 0..endmeta { 
            let tokenid =  vectIDs[x as usize];
            let mut token =self.get_token(tokenid.to_string());
            vectMEta.push(token  );
                    
        }  

        
    return vectMEta ;   
    }


      //solo obtiene los tokenid que esten en onsale y retorna un vec de META
    pub fn obtener_pagina_on_sale(& self,tokens: u64,_start_index: u64, _minprice:u64,_maxprice:u64,_date:u64) -> Vec<Meta>  {
        //insertar nuevo token a Hashmap
        let mut _map =self.tokenHM.clone();
        let mut vectIDs = vec![];
        let mut vectMEta = vec![];
        let ends= _map.len().to_string().parse::<u64>();
        let mut _tokfound =0;
        let mut i=0;
        let mut toksfilted:Vec<u64> = vec![];
        //comienza el filtrado segun los parametros
        //(tokens:N , _start_index:N,status:"S" ,account:"tes", price:N ,date:N)

            // (25,0, "null",0,0) ->Gallery
            if _minprice==0 && _maxprice==0 && _date==0 {

                let mut status =|p:u64 ,x : Vec<_> | { i+=1; x[0] =="S"  };
                toksfilted = _map.iter()
                     .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                     .map(|p| p.0.clone().parse::<u64>().unwrap() )
                     .collect() ;
                     toksfilted.sort();

            } // (25,0,"S","null",2,0) ->Gallery y price
            else if _minprice>=0 &&   _date==0 {
                let mut status =|tokeni:u64 ,vect2 : Vec<String> | 
                { i+=1; vect2[0] =="S" && vect2[3].parse::<u64>().unwrap() >=_minprice  && vect2[3].parse::<u64>().unwrap() <=_maxprice };
                toksfilted = _map.iter()
                     .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                     .map(|p| p.0.clone().parse::<u64>().unwrap() )
                     .collect();
                     toksfilted.sort();
                  if toksfilted.is_empty() {
                     log!("No se encontraron tokens entre {} y {}",_minprice,_maxprice);
                     return  vectMEta
                  }   
                      
            }// (25,0,"S","null",0,2143234) ->Gallery y date
            else if _minprice==0 && _date>0 {

            }// (25,0,"null",2,2132433543) ->Gallery , price y date
            else if _minprice>0 && _date>0 {

            }


        
         
        
           
            // (25,0,"S","null",2,2132433543) ->Gallery , price y date
        // (25,0,"U","d.testnet",0,0) -> Gallery's artis
            // (25,0,"U","d.testnet",2,0) -> Gallery's artis y price
            // (25,0,"U","d.testnet",2,2234235443) -> Gallery's artis, price y date
        // (25,0,"A","null",0,0) ->Gallery auction
           // (25,0,"A","null",2,0) ->Gallery y price
            // (25,0,"A","null",2,2132433543) ->Gallery , price y date

         
      //  let ends= _map.len().to_string().parse::<u64>().unwrap();
        
      
        
        //este ciclo recupera los primeros
        for x in _start_index..ends.unwrap()  {
              _tokfound+=1;
                if _tokfound > tokens  {break;}      
            let tok = toksfilted[x as usize];
            //log!("{}",tok.clone());

                     vectIDs.push(tok );
                
        }  

        let endmeta = vectIDs.len().to_string().parse::<u64>().unwrap();
        //en este ciclo recupera los tokens que encontramos anteriormente
          for x in 0..endmeta { 
            let tokenid =  vectIDs[x as usize];
            let  token =self.get_token(tokenid.to_string());
     
            vectMEta.push(token  );
                    
        }  

        
    return vectMEta ;   
    }



       //obtiene paginacion de los tokens en venta
    pub fn get_pagination_onsale(&self,tokens:u64) ->  Vec<u64> {
        let mut vectIDs = vec![];
        let mut _tokfound =0;
        let mut _map =self.tokenHM.clone();
      //  let ends= _map.len().to_string().parse::<u64>().unwrap();
        
        let mut status =|x : Vec<_> | {   x[0] =="S"  };
        let mut toksfilted: Vec<u64> = _map.iter()
                .filter(|st| status(st.1.clone()))
                .map(|p| p.0.clone().parse::<u64>().unwrap() )
                .collect() ;
                toksfilted.sort();
     //     log!("{:?}",toksfilted);
          vectIDs.push(0);
        for x in 0..toksfilted.clone().len()-1 { 
             _tokfound+=1;
           if _tokfound== tokens {   
                    vectIDs.push(x as u64 +1);  
                    _tokfound=0;  
                    }
            
           
            
            if x == toksfilted.clone().len() {break; }            
        }
        vectIDs
        //return toksfilted[0..25].to_vec();
    }

    //solo obtiene los tokenid que esten en onsale y retorna un vec de META
    pub fn get_pagination_onsale_filters(& self,chunk:usize,tokens: u64,_start_index: u64, _minprice:u128,_maxprice:u128,_mindate:f64,_maxdate:f64) -> Vec<u64>  {
        //insertar nuevo token a Hashmap
        let mut _map =self.tk_chunk[chunk].clone();
        let mut vectIDs = vec![];
        let mut vectMEta = vec![];
        let ends= _map.len().to_string().parse::<u64>();
        let mut _tokfound =0;
        
        let mut i=0;
        let mut toksfilted:Vec<u64> = vec![];
        //comienza el filtrado segun los parametros
        //(tokens:N , _start_index:N,status:"S" ,account:"tes", price:N ,date:N)
            // (25,0, "null",0,0) ->Gallery
                    if _minprice==0 && _maxprice==0 && _mindate==0.0 && _maxdate==0.0{
                        let mut status =|p:u64 ,x : Vec<_> | { i+=1; x[0] =="S"  };
                        toksfilted = _map.iter()
                            .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                            .map(|p| p.0.clone().parse::<u64>().unwrap() )
                            .collect() ;
                            toksfilted.sort();
                        if toksfilted.is_empty() {
                            //    log!("No hay tokens aun");
                                return  vectMEta
                            }
                        //    log!("sin filtro salida");  
                    } // (25,0, 2,6,0,0) ->Gallery y price between range
                    else if _minprice >0 && _maxprice>0 && _mindate==0.0 && _maxdate==0.0 {
                        let mut status =|tokeni:u64 ,vect2 : Vec<String> |
                        { i+=1; vect2[0] =="S" && vect2[3].parse::<u128>().unwrap() >= (_minprice*1000000000000000000000000)  && vect2[3].parse::<u128>().unwrap() <=(_maxprice*1000000000000000000000000) };
                        toksfilted = _map.iter()
                            .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                            .map(|p| p.0.clone().parse::<u64>().unwrap() )
                            .collect();
                            toksfilted.sort();
                        if toksfilted.is_empty() {
                        //    log!("No se encontraron tokens entre {} y {}  ,{},{}",_minprice,_maxprice,(_minprice*1000000000000000000000000),(_maxprice*1000000000000000000000000));
                            return  vectMEta
                        }  
                    }// (25,0, 4,0,0,0) ->Gallery and less than min price
                    else if _minprice >0 && _maxprice==0 && _mindate==0.0 && _maxdate==0.0 {
                        let mut status =|tokeni:u64 ,vect2 : Vec<String> |
                        { i+=1; vect2[0] =="S" && vect2[3].parse::<u128>().unwrap() <=(_minprice*1000000000000000000000000)   };
                        toksfilted = _map.iter()
                            .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                            .map(|p| p.0.clone().parse::<u64>().unwrap() )
                            .collect();
                            toksfilted.sort();
                        if toksfilted.is_empty() {
                      //      log!("No se encontraron tokens entre {} y {}",_minprice,_maxprice);
                            return  vectMEta
                        }  
                    }
                    // (25,0, 0,12,0,0) ->Gallery and more than max price
                    else if _minprice ==0 && _maxprice>0 && _mindate==0.0 && _maxdate==0.0 {
                        let mut status =|tokeni:u64 ,vect2 : Vec<String> |
                        { i+=1; vect2[0] =="S" && vect2[3].parse::<u128>().unwrap() >=(_maxprice*1000000000000000000000000)  };
                        toksfilted = _map.iter()
                            .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                            .map(|p| p.0.clone().parse::<u64>().unwrap() )
                            .collect();
                            toksfilted.sort();
                        if toksfilted.is_empty() {
                          //  log!("No se encontraron tokens entre {} y {}",_minprice,_maxprice);
                            return  vectMEta
                        }  
                    }
                    // (25,0, 0,0,yesterday,today) ->Gallery and  range between 2 date
                    else if _minprice ==0 && _maxprice==0 && _mindate>0.0 && _maxdate>0.0{
                        let mut status =|tokeni:u64 ,vect2 : Vec<String> |
                        { i+=1; vect2[0] =="S" && vect2[4].substring(0, 13).parse::<f64>().unwrap() >=_mindate  && vect2[4].substring(0, 13).parse::<f64>().unwrap() <=_maxdate };
                        toksfilted = _map.iter()
                            .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                            .map(|p| p.0.clone().parse::<u64>().unwrap() )
                            .collect();
                            toksfilted.sort();
                        if toksfilted.is_empty() {
                        //    log!("No se encontraron tokens entre la fechas {} y {}",_mindate,_maxdate);
                            return  vectMEta
                        }  
                    }
                    // (25,0, 0,0,yesterday,today) ->Gallery and  less than mindate
                    else if _minprice ==0 && _maxprice==0 && _mindate>0.0 && _maxdate==0.0{
                        let mut status =|tokeni:u64 ,vect2 : Vec<String> |
                        { i+=1; vect2[0] =="S" && vect2[4].substring(0, 13).parse::<f64>().unwrap() <=_mindate  };
                        toksfilted = _map.iter()
                            .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                            .map(|p| p.0.clone().parse::<u64>().unwrap() )
                            .collect();
                            toksfilted.sort();
                        if toksfilted.is_empty() {
                    //        log!("No se encontraron tokens entre la fechas {} y {}",_mindate,_maxdate);
                            return  vectMEta
                        }  
                    }
                    // (25,0, 0,0,yesterday,today) ->Gallery and  more  than maxdate
                    else if _minprice ==0 && _maxprice==0 && _mindate==0.0 && _maxdate>0.0{
                        let mut status =|tokeni:u64 ,vect2 : Vec<String> |
                        { i+=1; vect2[0] =="S" && vect2[4].substring(0, 13).parse::<f64>().unwrap() >=_maxdate  };
                        toksfilted = _map.iter()
                            .filter(|st| status(st.0.clone().parse::<u64>().unwrap() ,st.1.clone()))
                            .map(|p| p.0.clone().parse::<u64>().unwrap() )
                            .collect();
                            toksfilted.sort();
                        if toksfilted.is_empty() {
                      //      log!("No se encontraron tokens entre la fechas {} y {}",_mindate,_maxdate);
                            return  vectMEta
                        }  
                    }
            
       //     log!("{:?}",toksfilted);
        //    //vectIDs.push(0);  
            for x in 0..toksfilted.clone().len()-1 { 
                _tokfound+=1;
            if _tokfound== tokens {   
                    vectIDs.push(x as u64 +1);  
                    _tokfound=0;  
                    }
            
            
            
            if x == toksfilted.clone().len() {break; }            
        }

        return vectIDs;
    }



       //solo obtiene los tokenid que esten en onsale y retorna un vec de META
    pub fn obtener_pagina_on_auction(&   self,tokens: u64,_start_index: u64 ) -> Vec<Meta> {
        //insertar nuevo token a Hashmap
        let mut _map =self.tokenHM.clone();
        let mut vectIDs = vec![];
        let mut vectMEta = vec![];
        let ends= _map.len().to_string().parse::<u64>();
        
        //este ciclo recupera los primeros
        for x in _start_index..ends.unwrap()  {
            
            if vectIDs.len() >= tokens as usize { // log!("max {} ",&x); 
            break ;}
        
            let tok = _map.get(&x.to_string() ).unwrap();
            if tok[0] == "onauction".to_string()  {
                
                    vectIDs.push(x.to_string().parse::<u64>().unwrap() );
                
            }       
            
        }

        let endmeta = vectIDs.len().to_string().parse::<u64>().unwrap();
        //en este ciclo recupera los tokens que encontramos anteriormente
          for x in 0..endmeta { 
            let tokenid =  vectIDs[x as usize];
            let mut token =self.get_token(tokenid.to_string());
            vectMEta.push(token  );
                    
        }  

        
    return vectMEta ;   
    }
    pub fn obtener_pagina_by_owner(&self,account: ValidAccountId) -> Vec<Meta>  {
         //insertar nuevo token a Hashmap
         let mut _map =self.tokenHM.clone();
         let mut vectIDs = vec![];
         let mut vectMEta = vec![];
         let ends= _map.len().to_string().parse::<u64>();
         
         //este ciclo recupera los primeros
         for x in 0..ends.unwrap()  {
            let tok = _map.get(&x.to_string() ).unwrap();
             if tok[2] == account.to_string()  {
                  vectIDs.push(x.to_string().parse::<u64>().unwrap() );
             }                  
         }
 
         let endmeta = vectIDs.len().to_string().parse::<u64>().unwrap();
         //en este ciclo recupera los tokens que encontramos anteriormente
           for x in 0..endmeta { 
             let tokenid =  vectIDs[x as usize];
             let mut token =self.get_token(tokenid.to_string());
             vectMEta.push(token);
                     
         }  
 
         
     return vectMEta ; 
         
    }
    pub fn obtener_pagina_by_creator(&self,account: ValidAccountId) -> Vec<Meta>  {
        //insertar nuevo token a Hashmap
        let mut _map =self.tokenHM.clone();
        let mut vectIDs = vec![];
        let mut vectMEta = vec![];
        let ends= _map.len().to_string().parse::<u64>();
        
        //este ciclo recupera los primeros
        for x in 0..ends.unwrap()  {
           let tok = _map.get(&x.to_string() ).unwrap();
            if tok[1] == account.to_string()  {
                 vectIDs.push(x.to_string().parse::<u64>().unwrap() );
            }                  
        }

        let endmeta = vectIDs.len().to_string().parse::<u64>().unwrap();
        //en este ciclo recupera los tokens que encontramos anteriormente
          for x in 0..endmeta { 
            let tokenid =  vectIDs[x as usize];
            let mut token =self.get_token(tokenid.to_string());
            vectMEta.push(token);
                    
        }  

        
    return vectMEta ; 
        
   }

       pub fn tokens_of(&self, account_id: ValidAccountId,from_index: U128,limit: u64,) -> Vec<Token> {
        return self
            .tokens
            .nft_tokens_for_owner(account_id, Some(from_index), Some(limit));
    }
